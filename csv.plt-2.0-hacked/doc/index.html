<html lang="en">
<head>
<title>csv.scm: Comma-Separated Value (CSV) Utilities in Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="csv.scm: Comma-Separated Value (CSV) Utilities in Scheme">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<a name="Top"></a>

<h2 class="unnumbered">csv.scm: Comma-Separated Value (CSV) Utilities in Scheme</h2>

<p class="noindent">Version <b>0.5</b>, 2005-12-09, <a href="http://www.neilvandyke.org/csv-scm/">http://www.neilvandyke.org/csv-scm/</a>

<p class="noindent">by
Neil W. Van Dyke
&lt;<code>neil@neilvandyke.org</code>&gt;

   <blockquote>
Copyright &copy; 2004 - 2005 Neil W. Van Dyke.  This program is Free
Software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software
Foundation; either version 2.1 of the License, or (at your option) any
later version.  This program is distributed in the hope that it will be
useful, but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.  See
&lt;<code>http://www.gnu.org/copyleft/lesser.html</code>&gt; for details.  For
other license options and consulting, contact the author. 
</blockquote>

<h2 class="chapter">Introduction</h2>

<p>The <code>csv.scm</code> Scheme library provides utilities for reading various
kinds of what are commonly known as &ldquo;comma-separated value&rdquo; (CSV) files. 
Since there is no standard CSV format<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>, this library
permits CSV readers to be constructed from a specification of the
peculiarities of a given variant.  A default reader handles the majority of
formats.

   <p>One of the main uses of this library is to import data from old crusty
legacy applications into Scheme for data conversion and other processing. 
To that end, this library includes various conveniences for iterating over
parsed CSV rows, and for converting CSV input to the
<a href="http://pobox.com/~oleg/ftp/Scheme/SXML.html">SXML 3.0</a> Scheme XML
format.

   <p>This library requires R5RS, SRFI-6, SRFI-23, and an <code>integer-&gt;char</code>
procedure that accepts ASCII values.

   <p>Other implementations of some kind of CSV reading for Scheme include
Gauche's <code>text.csv</code> module, and the Scsh's <code>record-reader</code> and
related procedures.  This library intends to be portable and more
comprehensive.

<h2 class="chapter">Reader Specs</h2>

<p>CSV readers are constructed using <dfn>reader specs</dfn>, which are sets of
attribute-value pairs, represented in Scheme as association lists keyed on
symbols.  Each attribute has a default value if not specified otherwise. 
The attributes are:

     <dl>
<dt><code>newline-type</code><dd>Symbol representing the newline, or record-terminator, convention.  The
convention can be a fixed character sequence (<code>lf</code>, <code>crlf</code>, or
<code>cr</code>, corresponding to combinations of line-feed and carriage-return),
any string of one or more line-feed and carriage-return characters
(<code>lax</code>), or adaptive (<code>adapt</code>).  <code>adapt</code> attempts to detect
the newline convention at the start of the input and assume that convention
for the remainder of the input.  Default: <code>lax</code>

     <br><dt><code>separator-chars</code><dd>Non-null list of characters that serve as field separators.  Normally, this
will be a list of one character.  Default: <code>(#\,)</code> (list of the comma
character)

     <br><dt><code>quote-char</code><dd>Character that should be treated as the quoted field delimiter character,
or <code>#f</code> if fields cannot be quoted.  Note that there can be only one
quote character.  Default: <code>#\"</code> (double-quote)

     <br><dt><code>quote-doubling-escapes?</code><dd>Boolean for whether or not a sequence of two <code>quote-char</code> quote
characters within a quoted field constitute an escape sequence for
including a single <code>quote-char</code> within the string.  Default: <code>#t</code>

     <br><dt><code>comment-chars</code><dd>List of characters, possibly null, which comment out the entire line of
input when they appear as the first character in a line.  Default:
<code>()</code> (null list)

     <br><dt><code>whitespace-chars</code><dd>List of characters, possibly null, that are considered <dfn>whitespace</dfn>
constituents for purposes of the <code>strip-leading-whitespace?</code> and
<code>strip-trailing-whitespace?</code> attributes described below. 
Default: <code>(#\space)</code> (list of the space character)

     <br><dt><code>strip-leading-whitespace?</code><dd>Boolean for whether or not leading whitespace in fields should be
stripped.  Note that whitespace within a quoted field is never stripped. 
Default: <code>#f</code>

     <br><dt><code>strip-trailing-whitespace?</code><dd>Boolean for whether or not trailing whitespace in fields should be
stripped.  Note that whitespace within a quoted field is never stripped. 
Default: <code>#f</code>

     <br><dt><code>newlines-in-quotes?</code><dd>Boolean for whether or not newline sequences are permitted within quoted
fields.  If true, then the newline characters are included as part of the
field value; if false, then the newline sequence is treated as a premature
record termination.  Default: <code>#t</code>

   </dl>

<h2 class="chapter">Making Reader Makers</h2>

<p>CSV readers are procedures that are constructed dynamically to close over a
particular CSV input and yield a parsed row value each time the procedure
is applied.  For efficiency reasons, the reader procedures are themselves
constructed by another procedure, <code>make-csv-reader-maker</code>, for
particular CSV reader specs.

<div class="defun">
&mdash; Procedure: <b>make-csv-reader-maker</b><var> reader-spec<a name="index-make_002dcsv_002dreader_002dmaker-1"></a></var><br>
<blockquote>
<p>Constructs a CSV reader constructor procedure from the <var>reader-spec</var>,
with unspecified attributes having their default values.

        <p>For example, given the input file <code>fruits.csv</code> with the content:

     <pre class="example">          apples  |  2 |  0.42
          bananas | 20 | 13.69
     </pre>
        <p>a reader for the file's apparent format can be constructed like:

     <pre class="lisp">          (define make-food-csv-reader
            (make-csv-reader-maker
             '((separator-chars            . (#\|))
               (strip-leading-whitespace?  . #t)
               (strip-trailing-whitespace? . #t))))
     </pre>
        <p>The resulting <code>make-food-csv-reader</code> procedure accepts one argument,
which is either an input port from which to read, or a string from which to
read.  Our example input file then can be be read by opening an input port
on a file and using our new procedure to construct a reader on it:

     <pre class="lisp">          (define next-row
            (make-food-csv-reader (open-input-file "fruits.csv")))
     </pre>
        <p>This reader, <code>next-row</code>, can then be called repeatedly to yield a
parsed representation of each subsequent row.  The parsed format is a list
of strings, one string for each column.  The null list is yielded to
indicate that all rows have already been yielded.

     <pre class="lisp">          (next-row) =&gt; ("apples" "2" "0.42")
          (next-row) =&gt; ("bananas" "20" "13.69")
          (next-row) =&gt; ()
     </pre>
        </blockquote></div>

<h2 class="chapter">Making Readers</h2>

<p>In addition to being constructed from the result of
<code>make-csv-reader-maker</code>, CSV readers can also be constructed using
<code>make-csv-reader</code>.

<div class="defun">
&mdash; Procedure: <b>make-csv-reader</b><var> in </var>[<var>reader-spec</var>]<var><a name="index-make_002dcsv_002dreader-2"></a></var><br>
<blockquote>
<p>Construct a CSV reader on the input <var>in</var>, which is an input port or a
string.  If <var>reader-spec</var> is given, and is not the null list, then a
&ldquo;one-shot&rdquo; reader constructor is constructed with that spec and used.  If
<var>reader-spec</var> is not given, or is the null list, then the default CSV
reader constructor is used.  For example, the reader from the
<code>make-csv-reader-maker</code> example could alternatively have been
constructed like:

     <pre class="lisp">          (define next-row
            (make-csv-reader
             (open-input-file "fruits.csv")
             '((separator-chars            . (#\|))
               (strip-leading-whitespace?  . #t)
               (strip-trailing-whitespace? . #t)))))
     </pre>
        </blockquote></div>

<h2 class="chapter">Basic Input Conveniences</h2>

<p>Several convenience procedures are provided for iterating over the CSV rows
and for converting the CSV into a list.  To the dismay of some Scheme
purists, each of these procedures accepts a <var>reader-or-in</var> argument,
which can be a CSV reader, an input port, or a string.  If not a CSV
reader, then the default reader constructor is used.  For example, all
three of the following are equivalent:

<pre class="lisp">     (csv-&gt;list                                     <var>string</var>  )
     ==
     (csv-&gt;list (make-csv-reader                    <var>string</var> ))
     ==
     (csv-&gt;list (make-csv-reader (open-input-string <var>string</var>)))
</pre>
   <div class="defun">
&mdash; Procedure: <b>csv-for-each</b><var> proc reader-or-in<a name="index-csv_002dfor_002deach-3"></a></var><br>
<blockquote>
<p>Similar to Scheme's <code>for-each</code>, applies <var>proc</var>, a procedure of one
argument, to each parsed CSV row in series.  <var>reader-or-in</var> is the CSV
reader, input port, or string.  The return
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>csv-map</b><var> proc reader-or-in<a name="index-csv_002dmap-4"></a></var><br>
<blockquote>
<p>Similar to Scheme's <code>map</code>, applies <var>proc</var>, a procedure of one
argument, to each parsed CSV row in series, and yields a list of the values
of each application of <var>proc</var>, in order.  <var>reader-or-in</var> is the CSV
reader, input port, or string. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>csv-&gt;list</b><var> reader-or-in<a name="index-csv_002d_003elist-5"></a></var><br>
<blockquote>
<p>Yields a list of CSV row lists from input <var>reader-or-in</var>, which is a
CSv reader, input port, or string. 
</p></blockquote></div>

<h2 class="chapter">Converting CSV to SXML</h2>

<p>The <code>csv-&gt;sxml</code> procedure can be used to convert CSV to [SXML] format,
for processing with various XML tools.

<div class="defun">
&mdash; Procedure: <b>csv-&gt;sxml</b><var> reader-or-in </var>[<var>row-element </var>[<var>col-elements</var>]]<var><a name="index-csv_002d_003esxml-6"></a></var><br>
<blockquote>
<p>Reads CSV from input <var>reader-or-in</var> (which is a CSV reader, input port,
or string), and yields an SXML representation.  If given, <var>row-element</var>
is a symbol for the XML row element.  If <var>row-element</var> is not given,
the default is the symbol <code>row</code>.  If given <var>col-elements</var> is a
list of symbols for the XML column elements.  If not given, or there are
more columns in a row than given symbols, column element symbols are of the
format <code>col-</code><var>n</var>, where <var>n</var> is the column number (the first
column being number 0, not 1).

        <p>For example, given a CSV-format file <code>friends.csv</code> that has the
contents:

     <pre class="example">          Binoche,Ste. Brune,33-1-2-3
          Posey,Main St.,555-5309
          Ryder,Cellblock 9,
     </pre>
        <p>with elements not given, the result is:

     <pre class="lisp">          (csv-&gt;sxml (open-input-file "friends.csv"))
          =&gt;
          (*TOP*
           (row (col-0 "Binoche") (col-1 "Ste. Brune")  (col-2 "33-1-2-3"))
           (row (col-0 "Posey")   (col-1 "Main St.")    (col-2 "555-5309"))
           (row (col-0 "Ryder")   (col-1 "Cellblock 9") (col-2 "")))
     </pre>
        <p>With elements given, the result is like:

     <pre class="lisp">          (csv-&gt;sxml (open-input-file "friends.csv")
                     'friend
                     '(name address phone))
          =&gt;
          (*TOP* (friend (name    "Binoche")
                         (address "Ste. Brune")
                         (phone   "33-1-2-3"))
                 (friend (name    "Posey")
                         (address "Main St.")
                         (phone   "555-5309"))
                 (friend (name    "Ryder")
                         (address "Cellblock 9")
                         (phone   "")))
     </pre>
        </blockquote></div>

<h2 class="chapter">Tests</h2>

<p>The <code>csv.scm</code> test suite can be enabled by editing the source code
file and loading <a href="http://www.neilvandyke.org/testeez/">Testeez</a>.

<h2 class="unnumbered">History</h2>

     <dl>
<dt>Version 0.5 &mdash; 2005-12-09<dd>Changed a non-R5RS use of <code>letrec</code> to <code>let*</code>, caught by Guile and
David Pirotte.

     <br><dt>Version 0.4 &mdash; 2005-06-07<dd>Converted to Testeez.  Minor documentation changes.

     <br><dt>Version 0.3 &mdash; 2004-07-21<dd>Minor documentation changes.  Test suite now disabled by default.

     <br><dt>Version 0.2 &mdash; 2004-06-01<dd>Fixed strange <code>case</code>-related bug exhibited under Gauche 0.8 and
0.7.4.2 in <code>csv-internal:make-portreader/positional</code>.  Thanks to
Grzegorz Chrupa/la for reporting.

     <br><dt>Version 0.1 &mdash; 2004-05-31<dd>First release, for testing with real-world input.

</dl>

   <div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> &ldquo;The Comma Separated Value
(CSV) File Format: Create or parse data in this popular pseudo-standard
format,&rdquo; Web page, viewed 2004-05-26,
<a href="http://www.creativyst.com/Doc/Articles/CSV/CSV01.htm">http://www.creativyst.com/Doc/Articles/CSV/CSV01.htm</a></p>

   <p><hr></div>

</body></html>

